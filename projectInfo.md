Dobře, podrobně projdu celý projekt NebulaLang včetně všech složek a souborů. Zaměřím se na architekturu, kvalitu kódu, bezpečnostní přístup, inovativnost i potenciál pro další rozvoj. U každé části uvedu konkrétní komentáře a hodnocení, a připravím strukturovanou zprávu, která ti pomůže lépe prezentovat projekt i rozhodnout o dalších krocích.

Jakmile bude analýza připravena, dám ti vědět.


# Hodnotící zpráva projektu NebulaLang

## 1. Orchestrace sektorů

1. **Účel a funkce:** Komponenta **SectorOrchestrator** řídí směrování uživatelských záměrů („intents“) do příslušných sektorů. Uchovává seznam registrovaných sektorů a mapu záměrů na sektory, rozhoduje, který sektor zpracuje daný požadavek na základě tokenu (role a úrovně „důvěry“). Posílá pak zprávy do sektorů přes interní komunikaci (*TunnelService*) a zaznamenává historii událostí (poslané zprávy, aktivované záměry). Součástí orchestrace je také *ghostQueue* pro latentní (stínové) scénáře, které se připravují pro případné pozdější vyvolání.
2. **Kvalita implementace:** Kód je modulární a dobře oddělený – logika rozhodování (IntentEvaluator) je separována od správy sektorů a komunikace. Třída `SectorOrchestrator` přehledně definuje metody `registerSector()`, `mapIntent()` a `activateIntent()`. Architektura umožňuje snadné rozšíření o nové sektory a pravidla. Čitelnost je dobrá (čitelné názvy a komentáře). Díky unit testům (např. **testOrchestrator.js**) je funkčnost ověřená, což posiluje testovatelnost. Na škálování lze působit přidáváním dalších instancí sektorů. Jedinou nevýhodou je, že logika je poměrně centrální – v budoucnu by bylo vhodné udělat ji distribuovatelnou či asynchronní.
3. **Bezpečnostní mechanismy:** Orchestrátor využívá **tokeny** (obsahují uživatelské ID, roli a úroveň důvěry) a komponentu **TrustSupervisor**. Při aktivaci záměru volá `IntentEvaluator` a kontroluje, zda token vyhovuje pravidlům (minimální důvěra a oprávnění). Poté aktualizuje důvěru uživatele (`TrustSupervisor.observeIntent()`) a tokenu přidá auditní záznam. Každý pokus o aktivaci či zaslání zprávy se loguje. Tímto způsobem se v rámci orchestrace aplikuje autorizace (role+trust) a auditní sledování. Chybí ale kryptografická ochrana tokenů (aktuálně se kontroluje jen prefix) či zabezpečení kanálu (jde o interní komunikaci). Přístupová práva jsou řešena staticky v poli `permissions` u tokenu, ale u volání sektorů a scénářů je hlavním kritériem právě `IntentEvaluator`.
4. **Inovativní prvky:** Orchestrace více sektorů („multi-sector orchestration“) je netypická: systém dokáže paralelně spravovat více domén (např. administrační, diagnostickou, auditu) a dynamicky nasměrovat požadavky. Inovativní je též stínová („shadow“) logika – když není záměr schválen, může se připravit *ghost scénář* pro pozdější provedení, což umožňuje pasivně sledovat nebo nacvičovat reakci na možný útok či operaci. Užití *IntentEvaluator* s adaptivním modelem důvěry (pomocí TrustSupervisor) podporuje decentralizované rozhodování a učení z historie. Celá konstrukce působí spíše jako výzkumný framework než tradiční API gateway.
5. **Praktické využití:** Tento přístup se hodí tam, kde je potřeba modulární a kontextová bezpečnostní architektura, například v enterprise aplikacích s oddělenými moduly (finanční, administrativní, monitorovací). Může být použit ve složitých systémech pro řízení workflows nebo v integracích mikroslužeb, kde každý *sektor* představuje jiný subsystém. Výhodný je v prostředích s rozdílnými bezpečnostními politikami (např. interní vs externí operace). Díky auditním mechanismům je vhodný pro regulovaná odvětví (bankovnictví, zdravotnictví) a pro výzkum adaptivních bezpečnostních algoritmů.
6. **Slabiny a rizika:** Současná implementace moc nereaguje na neočekávané situace – pokud žádné pravidlo nezapadne, záměr je jednoduše odmítnut. Neřeší se například fronty, paralelizace či prioritizace více současných požadavků. Rizikem je závislost na ručně definovaných pravidlech, která mohou být neúplná. V omezené spolehlivosti plní orchestrátor rutinní úlohy, ale při výpadku nebo chybě může zablokovat část systému. Také ghost scénáře jsou jen v paměti a není řešeno vyčištění starých záznamů (paměťový leak).
7. **Doporučení pro další vývoj:** Rozšířit konfiguraci orchestrátoru (např. načítat pravidla z externího souboru) a doplnit dokumentaci pro správce pravidel. Umožnit dynamické přidávání sektorů a pravidel za běhu (hot-reload). Zvýšit automatizaci testů pro komplikované scénáře a vytvářet simulace více současných záměrů. Zvážit UI nástroje pro vizualizaci toků mezi sektory a stavů orchestrátoru (pro ladění a auditorium). Přidat robustní persistentní mechanismus pro ghostQueue (aby se ghost scénáře neshazovaly restartem). V konečném kroku nasadit clusterové uspořádání pro orchestraci do většího nasazení.

## 2. Bezpečnostní mechanismy

1. **Účel a funkce:** Bezpečnostní část definují hlavně **SecurityToken**, **TrustSupervisor** a auditní služby. `SecurityToken` reprezentuje ověřený přístup uživatele – obsahuje ID, roli, aktuální skóre důvěry a seznam oprávnění. `TrustSupervisor` sleduje historii akcí uživatele a adaptivně upravuje jeho důvěru (na základě procenta úspěšných operací). Komponenta **AuditService/AuditLogger** zaznamenává všechny klíčové události (spuštění scénářů, komunikační tunely, změny tokenu). Tyto mechanismy společně zajišťují autorizaci a audit.
2. **Kvalita implementace:** Implementace je dobře rozdělena do tříd. `SecurityToken` má jednoduché metody pro kontrolu oprávnění (`hasPermission`) i generování auditu (`generateAuditEntry`). `TrustSupervisor` jasně spravuje skóre důvěry ve slovníku na uživatele. Kód je čitelný a pokryt testy (**testToken.js**, **testSecurityToken.js**, **testTrustSupervisor.js**), což usnadňuje další vývoj. Architektura tyto komponenty odděluje (moduly token, trust, audit samostatně), a proto lze jednotlivé části snadno testovat či nahradit. Na škálovatelnost zasahují omezení: všechny záznamy jsou v paměti, neexistuje centralizovaná databáze auditních logů ani distribuovaná správa tokenů.
3. **Hodnocení bezpečnostních mechanismů:** Systém používá staticky definované role a přiřazená oprávnění (např. role „user“ má určitou množinu akcí). Důvěra uživatele se upravuje jemně a omezeně (inkrementální změny). Tím se vytváří dynamická politika: pokud uživatel mnohokrát uspěje v autorizaci, jeho skóre roste a naopak. Auditní logování je úplné a umožňuje zpětnou kontrolu (AuditService dokáže filtrovat a sumarizovat zápisy). Zároveň však chybí silná autentizace – metoda `verifySignature` je jen simulace prefixu, takže v praxi nebude token bezpečně ověřen. Není řešeno např. obnovení/správa klíčů. Bezpečnostní riziko představuje i to, že tokeny nejsou šifrované (přenášejí se interně bez další ochrany). Oprávnění jsou jednoduchá, ale fungují: například metoda `AccessControlledModule.call()` kontroluje povolení pomocí `hasPermission`. Předávání tokenu mezi komponentami je vnitřní, chybí ale omezení např. podle časových platností (až na 1hodinu ve validUntil). Celkově je návrh solidní pro prototyp, ale pro produkční nasazení by bylo potřeba zavést silnější mechanismy (TLS, JWT atd.).
4. **Inovativní prvky:** Neobvyklé je spojení klasické ACL (role/oprávnění) s adaptivní *scores* důvěry. Tato vícevrstvá bezpečnost umožňuje reagovat na chování uživatele – například více rizikové operace vyžadují vyšší skóre. Dále systém sleduje a vizualizuje historii důvěry (viz `TrustVisualizer`), což běžně nebývá součástí API. Audit log je rovněž koncipován tak, že zaznamenává nejen operace, ale dokonce generuje unikátní *traceId* pro každý záznam, což zvyšuje sledovatelnost. Tyto prvky umožňují budoucí implementaci strojového učení pro detekci anomálií na základě netypických změn v trust skórech. Tím NebulaLang posouvá tradiční ověřování o koncept adaptivní důvěryhodnosti, což je inovativní research-oriented vlastnost.
5. **Praktické využití:** Výstupy této architektury jsou použitelné v aplikacích vyžadujících detailní audit a dynamické řízení přístupu. Příklady: bezpečnostní informační systémy, kritické infrastruktury, bankovní aplikace nebo zdravotnické systémy, kde musí být každá akce logována a rizikové operace posuzovány individiuálně. Adaptivní model trust se hodí v prostředích, kde je potřeba zpřísňovat kontrolu při podezřelých událostech (např. při neobvyklém chování uživatele). Vhodné je také testovací prostředí či sandbox pro výzkum interakce člověk–počítač, protože platforma generuje bohatá meta-data. Pro běžné podnikové účely lze systém vylepšit propojením s existujícím IAM.
6. **Slabiny a rizika:** Zásadním omezením je, že současná verze tokenů a auditů funguje spíše jako mock-up – bez skutečného šifrování či zabezpečení kanálu. Riziko představují chybějící protokoly pro vypršení a revokaci tokenů, což by v produkci mohlo být kritické (stávající tok je pevně nastaven na 1 hodinu platnosti). Dále deleguje příliš mnoho na uživatelskou roli – neexistuje granularita nad formou dat či dalšími atributy. Audity jsou v paměti, takže při restartu aplikace se ztratí. Potenciálně nebezpečné je také vystavení detailů trust skóre samotným uživatelům (viz UI panel *SystemStatus*). Celkově by se dala bezpečnost posílit.
7. **Doporučení pro další vývoj:** Implementovat skutečné ověřování (např. JWT s podpisy), nasadit TLS pro komunikaci komponentami. Rozšířit system o správu revokací a refresh tokenů. Persistovat auditní logy do databáze pro dlouhodobou archivaci a analýzu. Doplnit automatizované penetrační testy a validátory permissions (aby nedocházelo k běhovým zranitelnostem). Jasně zdokumentovat model rolí a permissions, aby byl pro vývojáře i uživatele srozumitelný. Nakonec propojit trust model se stínovými simulacemi (aby pokles důvěry mohl vyvolat varování nebo zpřísnění kontroly).

## 3. Evaluace záměru a UI DSL

1. **Účel a funkce:** Tato část zajišťuje *odhad úmyslu uživatele* a dynamickou tvorbu uživatelského rozhraní. Komponenta **CommandInsights** sbírá historii příkazů (z logeru `CommandLogger`) a vypočítá souhrnné metriky – například jaký příkaz je nejčastější, jaký je aktuální *focus* uživatele (např. „recovery“), čas posledního příkazu aj. **IntentRouter** poté použije tyto informace a DSL (DSL je definováno textem, který se bere z například ze souboru) k tomu, aby rozhodl, které panely nebo komponenty UI se mají zobrazit. DSL (`UIDSLParser` + `UIDSLRuntime`) umožňuje definovat podmínky typu `when intent.focus == "recovery"`. Komponenta `UIDSLComponentAdapter` dále parsuje DSL a vrátí seznam aktivních panelů podle aktuálního kontextu (údajů o záměru). Součástí jsou také textové panely, jako **BehavioralIntentPanel**, které ukazují predikovaný úmysl v terminálové podobě.
2. **Kvalita implementace:** Kód je rozdělený na parsing a vyhodnocení (parser je jednoduchý, runtime vyhodnocuje jediný typ výrazu). DSL parser je sice minimalistický (parsuje jen klíčové slovo `panel` a podmínky typu `when`), ale funkční. `IntentRouter` elegantně integruje CommandInsights a UI DSL, kód je přehledný. Separace logiky (sběr dat) a prezentačního rozhodnutí (DSL) je dobře navržena. Projekt obsahuje unit testy (**testCommandInsights.js**, **testUIDSLRuntime.js**, **testUIDSLComponentAdapter.js**) pokrývající hlavní funkce – což zvyšuje důvěru v čitelnost a spolehlivost. Nevýhodou je, že DSL je statický text a zatím nemá úpravy za běhu. Celkově je ale implementace konzistentní s celkovým designem platformy.
3. **Bezpečnostní mechanismy:** Samotný mechanismus evaluace záměru a DSL se nezabývá bezpečností – nevynucuje např. oprávnění pro zobrazení jednotlivých panelů. V praxi by bylo možné zkombinovat DSL s kontrolou tokenu (např. nezobrazovat administrativní panely, pokud token nemá roli admin). V aktuální verzi se však řeší spíše obsah panelů na základě aktivity uživatele. Metody zde nepůsobí na data ani je nemění, takže z hlediska bezpečnosti přenosů či integrity nepředstavují riziko.
4. **Inovativní prvky:** Klíčovým přínosem je **behaviorálně řízená vizualizace** – UI reaguje na uživatelovy akce (příkazy) a upravuje se v reálném čase. Přístup „od příkazů k UI“ je netradiční. Shadow logika záměru se zde přímo neuplatňuje, ale predikce fokusů a automatický výběr komponent (UI DSL) je moderní prvek spíš z oblasti inteligentních rozhraní. V kontextu NebulaLang je inovativní ta integrace: například panel *MirrorTrace* vizualizuje stínová vyhodnocení (shadow UX), a panel *ScenarioVisualizer* živě ukazuje průběh ghost scénářů. Tyto vizualizační komponenty (i když částečně mimo samotné DSL) demonstrují neobvyklé možnosti kombinovat bezpečnost s adaptivní UI.
5. **Praktické využití:** Hodí se pro dashboardy a konzole, kde je žádoucí adaptivní zobrazení – například bezpečnostní operační centrum nebo UX systém, který se učí z chování uživatele. Každá aplikace, kde se na základě předchozí historie mění hlavní zobrazené informace, může těžit z tohoto přístupu. Např. při obnově hesla se UI zaměří na recovery funkce, pokud uživatel zřejmě řeší incident. Nebo v Asistentovi: systém může automaticky nabídnout „nejčastější akce“ na základě historie. Tento princip by mohl ocenit i e‑commerce (rekomendace na základě prohlížených kategorií), i když NebulaLang se primárně zaměřuje na bezpečnostní kontexty.
6. **Slabiny a rizika:** Jazyk DSL je velmi jednoduchý a neškálovatelný pro složitější podmínky – například neumí složitější logické operátory nebo výrazy než jednosvazkové porovnání. Neexistuje žádná validace DSL syntaktickými chybami mimo jednoduchý parser (chyby způsobí nejasné chování). Navíc je DSL oddělený od runtime konfigurace – jakákoli změna vyžaduje editaci textu. Nedostatek dokumentace znamená, že developeři budou tápat, jak vytvořit vlastní pravidla. Další riziko představuje, že predikce záměru nemusí být přesné – systém může zobrazovat nepotřebné panely nebo naopak nezobrazit potřebné. Uživatelé by mohli být zmatení, proč se UI mění bez zjevné příčiny.
7. **Doporučení pro další vývoj:** Rozšířit DSL (podpora více klíčových slov, složitější podmínky, logika AND/OR, citlivost na velká malá písmena apod.). Vytvořit vizuální editor pro DSL nebo alespoň zpětnou vazbu pro tvorbu pravidel (např. validátor DSL). Doplnit integraci DSL do reálného front-endu (aktuálně jsou panely částečně textové a React komponenty). Přidat dokumentaci a příklady použití (může být součástí [docs](/docs) v repu). U záměru by bylo vhodné propojit tuto vrstvu s bezpečnostními pravidly (např. nezobrazit „admin“ akce, pokud token nemá roli). Nakonec rozšířit testy o integraci DSL s UI (např. simulované scénáře).

## 4. Scénáře a jejich řízení

1. **Účel a funkce:** Komponenty **Scénáře** definuje posloupnosti kroků pro konkrétní operace. Např. `LoginScenario` zpracovává přihlášení, `RecoveryScenario` obnovu, `AlertScenario` vyvolání bezpečnostního poplachu. `ScenarioRegistry` drží seznam dostupných scénářů (login, recovery atd.) a na vyžádání instancuje příslušný scénář s danými vstupy. Scénáře mohou implementovat metody `run()` (spuštění) a/nebo `reflect()` (návrat stavu). Controller (`SessionController`) volá tyto scénáře pomocí `activateScenario()`. Během běhu scénáře zapisují data zpět do sdíleného *contextu* a generují zprávy do tunelu (např. aktivaci komponent). Každá aktivace scénáře se zaznamená do audit logu.
2. **Kvalita implementace:** Architektura scénářů je modulární: každý scénář je samostatná třída, registry je obecná. Systém podporuje doplnění nových scénářů staticky (přidáním do registry). Kód `SessionController` je relativně přehledný – pro nové scénáře stačí přidat do mapy `scenarioRegistry`. Testy (**testScenarioRegistry.js**, **testSimulatedIncidentFlow\.js**) ověřují základní funkčnost. Díky tomu je testovatelné, jak scenář mění stav kontextu i generuje výstup (viz `SessionController`). Implementace scénářů však zatím obsahuje jen základní logiku – není zde mnoho složitých stavů nebo interakcí. Čitelnost kódu je dobrá, většina scénářů definuje jen jednu nebo dvě odpovědi. Architektura podporuje více scénářů paralelně.
3. **Bezpečnostní mechanismy:** Při spuštění scénáře přijímají scénáře informace o tokenu (důvěra, validita) a mohou se podle toho chovat. Například login scénář vytvoří session jen pokud `trustScore` je dostatečný. Auditor zaznamená každý pokus. Scénář nemá vlastní autorizaci (to zajišťuje orchestrátor a trust). Zkoumá se ale platnost tokenu před spuštěním (dle kódu Controlleru). Proto celá řada scénářů může být spuštěna pouze autorizovaně. Audit zápis v tunelu zahrnuje jméno scénáře, což pomáhá zpětně zjistit, jaké akce uživatel provedl. Nebezpečím může být, že chybně navržený scénář dá uživateli více práv, než má – proto je dobré scénáře důsledně otestovat.
4. **Inovativní prvky:** V konceptu NebulaLang je zajímavé, že scénáře nejsou statické „chatbotové“ sekvence, ale interaktivní procesy s kontextem a důvěrovými daty. Možnost, že scénář může být připraven jako ghost („latentní“) a aktivován později je unikátní. Nicméně samotné scénáře jsou spíše standardní. Inovativní je spíše to, jak se kombinují s ostatními částmi (např. *InterSectorProtocol* umožňuje, aby výstup jednoho scénáře vyvolal spuštění dalšího scénáře v jiném sektoru). Tím vzniká síťově propojené chování. V testech najdeme například *simulaci incidentního flow*, kde scénáře spolu komunikují podle předem nastavených reakcí.
5. **Praktické využití:** Model scénářů se hodí všude, kde potřebujeme zpracovat vícekrokové procesy – např. proces autorizace, pravidelný audit, obnovení hesla, poplachový scénář atd. V podnikových aplikacích by se scénáře daly využít pro sekvenční kontroly (např. multi-faktorové ověření). V bezpečnostním kontextu lze nastavit různé reakce (scénáře) na incidenty. Scénáře také usnadňují testování – například testSimulatedIncidentFlow umožní simulovat útok, aniž bychom museli manuálně volat jednotlivé metody.
6. **Slabiny a rizika:** Scénáře zatím běží synchronně a jednorázově, není zde fronta ani plánovač časovačů pro delší procesy. Nerozvíjí se kontinuálně stav – po dokončení scénáře je většinou vydáno pár zpráv a hotovo. Bez pokročilého řešení stavu není možné scénář „pozastavit a obnovit“. Chybí také řízení verzí scénářů a izolace – pokud do scénáře vložíme chybu, může zasáhnout celý proces controlleru. V kódu se taky předpokládá, že scénář vždy existuje (vyvolá Error, pokud ne). Kromě toho chybí transparentní notifikace pro uživatele o průběhu scénáře (na UI by mohlo být zřetelnější, co se děje).
7. **Doporučení pro další vývoj:** Rozšířit existující scénáře o více kroků a stavové informace, a přidat nové (např. logout, změna hesla). Dokumentovat vstupy/výstupy scénářů. Přidat automatizované testy pokrývající neúspěšné cesty (např. co se stane, když je token neplatný). Zvážit asynchronní spouštění scénářů a možnosti přerušení. Integrovat scénáře s modulem audit (např. *AuditService* uvnitř scénářů) pro snadnější analýzu. V UI vytvořit zpětnou vazbu (např. *ScenarioVisualizer* již vykresluje průběh, může být rozšířen).

## 5. Sektory

1. **Účel a funkce:** *Sektor* (př. `AuditSector`, `LoginSector` aj.) je samostatná kontextová jednotka, reprezentovaná třídou **SectorNode**. Každý sektor má vlastní *TunnelService* (komunikační kanály), vlastní auditní službu (*AuditService*) a registry scénářů a modulů. Funkcí sektoru je poskytovat uzavřené prostředí pro zpracování přidělených úkolů. Např. `SectorNode.activateScenario()` spustí scénář registrovaný pro tento sektor a uloží průběžný výstup do audit logu. Sektor umí také *broadcastovat* zprávy do všech posluchačů tunelu systému. `SectorNode.callModule()` umožňuje volání modulů se společným kontextem. Každý sektor tak izoluje své scénáře, moduly a logy pro lepší modularitu.
2. **Kvalita implementace:** Kód sektoru je dobře navržený, třída drží vše důležité v kontextu (ID sektoru, token, kontext, tunel, audit, registry). Díky metodám `registerScenario()` a `registerModule()` lze do sektoru snadno přidávat nové prvky. V konstruktoru je navíc zajištěno naslouchání na kanálech `sector.ID`, což se hodí pro systémová hlášení. Sektory lze popsat pomocí `describe()`, což je užitečné pro introspekci (test **testSectorNode.js** kontroluje popis). Architektura slibuje dobrou čitelnost a oddělení komponent – scénáře v jednom modulu, moduly v jiném, audit zvlášť. Sektory lze izolovat/testovat po jednom, context je oddělen pro každý sektor. Na škálování lze sektory přidávat klidně do dalších instancí aplikace či serverů. Jako nedostatek lze zmínit, že moduly se zatím nikde automaticky neregistrují (sektor používá `ModuleRegistry`, ale žádný modul se výslovně nepřidává v kódu).
3. **Bezpečnostní mechanismy:** Každý sektor má vlastní instanci tokenu (kopii z hlavního tokenu) a auditní log. Volání scénářů a modulů v sektoru zaznamenává audit třída SectorNode (viz `activateScenario()` a `callModule()`). Tím se hlídá, kdo (jaký token, tedy jaký uživatel) co v sektoru provedl. Právo volat scénář nebo modul vychází z toho, co sektor dostal jako *mapping intentů* a jaké moduly jsou v registry. Ve **ModuleRegistry** se při volání ověřují permission tokenu (pokud je použito `AccessControlledModule`). Celkově sektor technicky drží data samostatně, ale bezpečnost zajišťují hlavně tokeny a audity – sektor nepřidává další vrstvy. Výhodou je, že každý sektor může mít vlastní „policy“ – například AuditSector by mohl spouštět pouze interní scénáře.
4. **Inovativní prvky:** Samotný koncept sektorů odpovídá moderním myšlenkám jako mikroservisy, ale v rámci aplikace. Kombinace s orchestrátorem je netradiční: Celý multi-sector model dává NebulaLang smysl jako modulární orchestrátor na jednom místě. Inovativní je i to, že sektory mají vlastní tunely a mohou si posílat zprávy nezávisle (např. z uživatelského vstupu na konkrétní sektory). Architektura je připravená pro rozšíření – například lze v budoucnu vkládat různé security group a policy pro každý sektor. Nicméně zatím je nejzajímavější právě způsob, jak orchestrátor koordinuje několik sektorů najednou, nikoli samotné sektory.
5. **Praktické využití:** Sektory lze použít pro čisté oddělení domén – např. v bankovní aplikaci by mohl jeden sektor obsluhovat přihlašování/účetní, jiný platby, třetí reportování. Díky separaci auditů lze pro každý sektor vést samostatnou stopu. Hodí se ve velkých softwarových řešeních, kde různé týmy nebo mikroservisy mají přísně oddělené odpovědnosti. Pro vývojáře přináší výhodu, že mohou vyvíjet scénáře a moduly odděleně pro každý sektor bez vzájemných kolizí.
6. **Slabiny a rizika:** V současné verzi není podpora pro izolaci běhu sektorů (např. sandboxing). Pokud by segment selhal, může ovlivnit celý orchestrátor (protože vše běží na stejném runtime). Je tu riziko duplikace kontextu – každý sektor kopíruje sdílený kontext (např. session), takže nemají sdílenou paměť na změny, což může vést k nekonzistenci. Dále absence automatické registrace modulů znamená, že modulový systém je podvyužitý. Pokud někdo vytvoří nový sektor bez patřičné konfigurace, může to vést k neočekávaným chybám.
7. **Doporučení pro další vývoj:** Vytvořit fázi inicializace, kde se sektory a jejich moduly automaticky načtou (např. z konfiguračního souboru nebo složek). Vyvinout administrativní UI či CLI pro správu sektorů a přehled jejich statistik (využít `describe()`). Zvážit přidání mechanismů pro omezení zdrojů (např. dočasné přidělování procesorového času sektorům). Implementovat lepší izolační vrstvy (možná i spuštění sektorů v samostatných procesech či kontejnerech). Nakonec doplnit testy pro chování v případě selhání jednoho sektoru (failover) a pro komunikaci mezi sektory.

## 6. Moduly

1. **Účel a funkce:** Moduly (`ModuleRegistry`, `AccessControlledModule` aj.) poskytují služby/jádrové funkce, které lze volat z různých částí systému. `ModuleRegistry` spravuje *AccessControlledModule* instance, které obsahují metody s integrovanou kontrolou oprávnění. Příkladem je `AuthCenter` modul (implementsion of core runtime Module), který má metodu `initSession` pro vytváření session. Moduly tedy zastupují business logiku (např. autentizace, datové operace) a mohou být volány ze scénářů nebo z jiných služeb. Každý modul má definován přístup (role) ke svým metodám a loguje každý use-case volání.
2. **Kvalita implementace:** Architektura modulů je solidní – module registry, module třídy a přidružení handlerů metod. Při volání metod se kontroluje, zda uživatelův token má požadovaná oprávnění (metoda `AccessControlledModule.call()`). `AuthCenter` použit jako instanci třídy `Module` ukazuje flexibilitu: navzdory rozdílnému stylu má modul definovanou logiku a kontrolu kontextu. Kód je modulární a testovatelný (viz **testAccessModule.js** a **testAuth.js**). Nicméně implementace je neúplná – moduly se nikde automaticky neregistrují a používají. Při volání `ModuleRegistry.call` se kontroluje existuje-li modul, ale v projektech zatím nebyly nastaveny žádné registry moduly. Kód pro oprávnění zpracuje `AccessControlledModule`, ale `AuthCenter` používá jiný model (core Module) bez oprávnění (pouze kontrola session). Matice permission/role je pevně uvedena v tokenu, ne v modulu, což zamezuje centralizaci práv.
3. **Bezpečnostní mechanismy:** Modulový systém podporuje oprávnění na úrovni metod – každá metoda lze při registraci definovat seznam potřebných permizí. `AccessControlledModule.call()` zkontroluje `token.hasPermission()` a odmítne přístup, pokud chybí. Poté zapisuje log volání v instančním logu modulu. Ve stávajícím kódu se však metody ručně registrují a není ukázáno, že by někdo volal externí moduly. V bezpečnostním smyslu je dobré, že modulový rámec existuje, ale vyžaduje aktivní správu (jinak bezpečnostní omezení nefungují). Pokud by byly moduly nasazeny, systém by uchovával stopu, kdo kdy danou funkci použil (pomocí vnitřního `log`). Je tu ale prostor pro zlepšení – např. u metod `Module.invoke` v `ModuleRegistry` se nijak nekontroluje rola ani záznam auditu.
4. **Inovativní prvky:** Samotná idea modulů není unikátní, ale zapojení přístupových práv na úrovni jednotlivých metod a evidování volání dává architektuře bezpečnostní povahu. `AuthCenter` demonstruje modulární a introspektivní přístup – modul si drží vlastní stav (session, status). Celkově modulový systém připravený pro přidání jakéhokoli custom kódu (model-neutrální) je flexibilním zázemím. To, že framework obsahuje jak modulární runtime třídu, tak i přístupově kontrolovaný modul, přibližuje standardy enterprise platform (něco jako kontrakty pro služby).
5. **Praktické využití:** Pokud by byly do systému přidány reálné moduly, NebulaLang by mohl fungovat jako *low-code platforma* pro bezpečnostní logiku – vývojáři by definovali moduly a scénáře a Orchestrator by je skládal dohromady. Např. modul pro tvorbu OTP, pro kalibrační služby, reporting aj. Hodí se pro situace, kde je třeba rychle rozšiřovat funkcionalitu bez zásahu do jádra (stačí přidat modul). V budoucnu by mohly moduly poskytovat webová API, přičemž NebulaLang by byl jejich aplikační vrstvou.
6. **Slabiny a rizika:** V implementaci nevyužívá modulární architektura plně potenciál – absence plně fungujícího registru modulů znamená, že moduly nejsou pro uživatele reálně dostupné. Řetězení povolení je trochu rozdělené – některé moduly kontrolují token, jiné ne, což může vést k bezpečnostním mezerám. `allowedCallers` a `integrityCheck` definice v modulu nejsou nikde vyhodnoceny, takže momentálně bez efektu. Případné chyby v modulech (nezachycené výjimky) by mohly vyřadit celý sektor, protože se neřeší chybové stavy.
7. **Doporučení pro další vývoj:** Automatizovat registraci modulů (např. prohledat adresář `/modules` a zaregistrovat všechny tam nalezené, nebo použít config). Zavést jednotný styl (buď přidávat moduly jen přes `AccessControlledModule`, nebo všechny přes core `Module`). Dále spustit reálné příklady modulů (např. integrace se systémem pro komunikaci s LDAP, Notifikační systém, Synchronizační služby) a pokrýt je testy. Vytvořit UI / CLI pro zobrazení seznamu modulů a jejich metod spolu s potřebnými permizemi. Pro zvýšení bezpečnosti doplnit modulární audity (zapisovat invokace modulu do centrálního AuditService, aby bylo možné sledovat cross-sector volání).

## 7. Služby

1. **Účel a funkce:** Projekt obsahuje různé podpůrné **služby**. Například **ActionExecutor** z `services/executor` provádí akce stanovené na kontextu (změna aktuální komponenty UI, aktivace audit režimu, zablokování přístupu apod.). Dále jsou třídy pro logování: **AuditLogger** (zachytí aktivity uživatele a scénáře) a **CommandLogger** (loguje příkazy zadané do rozhraní). Tunelová služba (**TunnelService**) zajišťuje vnitřní komunikaci přes kanály, umožňuje komponentám poslouchat a vysílat zprávy. Služba **MirrorVsActivationComparator** slouží k porovnávání stínového (`shadow`) rozhodování se skutečným výstupem (analytický nástroj, vyhodnotí, zda se záměry shodují).
2. **Kvalita implementace:** Služby jsou navrženy s jasným určením úlohy a relativně jednoduchou logikou. `ActionExecutor` je přehledný (switch-case nad akcemi) a zřetelně manipuluje s `context` a vrací textové zprávy popisující krok. Loggery ukládají přehledně čas, příkaz/zprávu a výsledek. Kód obsahuje testy (**testActionExecutor.js**, **testAuditLogger.js**, **testCommandLogger.js**, **testTunnelService.js**) a je tím dobře pokryt, což dokládá spolehlivost. Díky zavedení abstrakce `TunnelService` zůstává komunikace decoupled, není potřeba psát vlastní event handling. Jednotlivé loggery mají metody pro filtrování a export, což zvyšuje použitelnost. Na čitelnost a rozšiřitelnost by bylo lepší nahradit ručně psaný switch v executorovi plně konfigurovatelným mapováním akcí na funkce (tedy méně kódových slučovacích bodů).
3. **Bezpečnostní mechanismy:** AuditLogger zaznamenává každý důležitý krok i s otiskem tokenu (fingerprintem), což přispívá k auditovatelnosti. TunnelService samostatně bezpečnost neříká, jen umožňuje distribuovat zprávy mezi komponentami. ActionExecutor může aktivovat auditní režim (`ActivateAuditMode`), což dynamicky rozšíří přihlášení akcí do protokolů. Samotné služby nevyžadují další ověřování, ale závisí na tom, že volají je již autorizované části aplikace (Controller, Scénáře). Například `BlockAccess` v ActionExecutor přesměruje UI na *AccessDenied* – tímto se realizuje jednoduchá blokace. Souhrnně tedy služby samotné *nevynucují* bezpečnost (spíš logují a vykonávají autorizované příkazy), ale jejich existence umožňuje audit a kontrolu nad výsledky.
4. **Inovativní prvky:** Mezi služby patří i **MirrorVsActivationComparator** – to je nástroj pro debug-shadow mechanismus. Porovnává, zda stínová simulace (ghost predictions) odpovídá skutečně provedeným aktivačním logům. Tento analytický přístup není běžný v komerčních projektech a pomáhá ladit systém „jako by simulátor versus realita“. Dalším inovativním prvkem je záznam auditoru (`AuditLogger`) s extra *fingerprintem*, který neútočné provázání událostí s uživateli velmi zefektivňuje. Jinak standardní služby sledují osvědčené patterny – jsou tedy užitečné, ale samy o sobě nejsou výjimečné.
5. **Praktické využití:** Auditní a logovací služby jsou praktické ve všech aplikacích, kde potřebujeme sledovat chování uživatelů a zajišťovat auditní stopy. `ActionExecutor` typu služba je užitečná v systémech s modulární architekturou, kde chceme mít centrální kontrolu nad tím, co se provádí v rámci uživatelské session. V aplikacích a nástrojích pro monitoring a incident response by `MirrorVsActivationComparator` mohl sloužit pro reportování odlišností mezi predikcí a realitou. `TunnelService` je obecný publish/subscribe mechanismus – lze jej použít v jakémkoliv systému vyžadujícím komunikaci mezi nezávislými komponentami.
6. **Slabiny a rizika:** `ActionExecutor` je implementován jako pevný switch-case seznam akcí – to znamená, že pro novou akci musíme měnit kód. Chybí zde data-driven přístup (např. mapování názvu akce na callback) a správa rollbacku či chyb. Pokud by se v budoucnu počet akcí zvětšil, tento přístup se stane neudržitelný. Logovací služby zatím ukládají záznamy do prosté paměti – žádný export na disk ani do databáze není implementován (systém ztrácí data po restartu). `TunnelService` je jednoduchý, ale naopak může vést k nezamýšlenému zavolání handleru v nevhodnou dobu, pokud není konzistence kontrolována. V podstatě tu chybí centrální správa těchto služeb pro produkční prostředí.
7. **Doporučení pro další vývoj:** Refaktorovat `ActionExecutor` na konfigurovatelný pattern – například definovat akce a jejich dopady v JSON nebo jiném souboru, aby se nemusel měnit zdrojový kód. Přidat více asynchronních služeb (např. službu pro volání externích API, kterou by mohl sektor používat). Logery vylepšit o možnost exportu do souboru nebo externích logovacích systémů (např. syslog, Elastic). Pro **TunnelService** zavést autorizaci kanálů či šifrování zpráv, pokud by byly tunely mezi různými uzly. Všechny služby doplnit automatické testy integrace (aby bylo vidět, že spolu správně komunikují). Nakonec sjednotit styl zobrazení logů a notifikací (např. prostřednictvím GUI komponent pro monitorování).

## 8. Uživatelské rozhraní a komponenty

1. **Účel a funkce:** Rozhraní tvoří textové panely a React komponenty, které prezentují stav systému. Patří sem `SystemStatusPanel` (ukazuje přehled aktivního scénáře, roli a důvěru tokenu, audit mód apod.), `BehavioralIntentPanel` (vypisuje doporučený úmysl uživatele na základě `CommandInsights`) a další konzolové panely. Dále frontendové React komponenty **MirrorTracePanel** a **ScenarioVisualizer** (vizuální prvky pro vývojáře) – první zobrazuje historii „stínových“ záměrů v grafické podobě, druhý pak karty se stavem jednotlivých ghost scénářů (status, úroveň důvěry, logy). Výstupy z ActionExecutoru a SystemDiagnostics se zobrazují v těchto panelech, takže uživatel (administrátor) může snadno získat souhrn stavu bez nutnosti dešifrovat raw data.
2. **Kvalita implementace:** Třídy panelů mají metodu `render()`, která vrací pole řetězců pro zobrazení. Jsou jednoduché a přehledné – kód je krátký a srozumitelný, což usnadňuje údržbu. React komponenty jsou dobře strukturované, používají CSS moduly a zřetelné rozhraní (přijímají data jako props). Ovládání a styl odpovídají standardním postupům. Testy (**testSystemStatusPanel.js**, **testBehavioralIntentPanel.js**) ověřují, že panely správně zobrazují dané informace. Čitelnost je tedy vysoká. Jediný problém je nekonzistentní přístup – části UI jsou čistě textové (panely), zatímco jiné jsou moderní React s kaskádami stylů; sjednocení by zlepšilo použitelnost. Dalším zlepšením by bylo sjednotit jazyk výstupů (aktuálně jsou smíchané emoji a text).
3. **Bezpečnostní mechanismy:** UI komponenty samy o sobě nefiltrují žádné kritické informace. Prezentují data, která jim systém předá – například `SystemStatusPanel` ukazuje uživatelovu roli a skóre důvěry. Je zde nebezpečí, že se může odhalit moc interních dat (audit logy, důvěra), pokud do UI prohlédne uživatel, který k tomu nemá oprávnění. V reálné aplikaci by měl být přístup k těmto panelům omezen (např. pouze na uživatele se zvláštními rolemi). Také vizualizace scénářů a shadow trace by neměly být veřejně přístupné. Současná implementace tyto kontroly nemá (UI je nezávislé na tokenu), což doporučujeme doplnit (např. zabránit vykreslení panelu, pokud token nemá patřičné permission).
4. **Inovativní prvky:** Prezentace *stínových procesů* uživateli je unikátní – většina systémů by data o paralelních ghost scénářích vůbec nezobrazovala. Zde je nastavena **vizualizace shadow trace**, která pomáhá vývojářům pochopit, co systém očekává (test *ShadowBridge* a *ScenarioVisualizer* ukazují sofistikovaný přístup k UI, který je v běžných frameworcích neobvyklý). Dále *BehavioralIntentPanel* ukazuje *predikci záměru* s emotikony a kontextem; to se blíží feature z oblasti inteligentních asistentů. Ukazuje to kontextově adaptivní design – panely se mohou objevit v reakci na uživatelův postup (kombinace IntentRouter a UI DSL), což působí jako živoucí UI. Tyto prvky jsou rozhodně inovativní oproti tradičnímu statickému rozhraní.
5. **Praktické využití:** Komponenty jsou primárně navrženy jako *dashboardy pro administrátora* nebo vývojáře. Klidně by mohly sloužit jako součást „security cockpit“, kde operátor vidí stav systému a doporučení. `SystemStatusPanel` například rychle informuje o tom, co se děje v backendu (uživatelská session, aktivní audit). React komponenty lze vložit do webové aplikace pro správu, čímž vznikne uživatelsky přívětivé ovládací GUI. V praxi by takový přístup využili například tým pro analýzu incidentů nebo bezpečnostní inženýr, kteří potřebují přehled o aktuálních a stínových akcích bez hledání v log souborech.
6. **Slabiny a rizika:** Přechod mezi CLI-like panely a React UI působí nejednotně – pro uživatele to může být matoucí. Textové panely jsou omezené na řádkový výstup a nelze je dynamicky ovlivnit (nelze na ně kliknout, chybí scroll v našem wrapperu). Pokud by se rozhraní mělo rozšířit (např. konfigurátor NebulaLang), současné panely by nepostačovaly. Dalším rizikem je, že chybějící role-based rozlišení může vést k neočekávanému zpřístupnění citlivých informací (jak bylo zmíněno výše). Také není ošetřen input od uživatele – SystemStatusPanel a BehavioralIntentPanel pouze zobrazují data, neumožňují interakci (např. spustit audit, stínovou simulaci apod.).
7. **Doporučení pro další vývoj:** Postupně sjednotit UI vrstvu – buď celý systém udělat jako webovou aplikaci v Reactu, nebo udržet čistě konzolové panely pro debugging. Doplnit chybějící panel *AccessDenied* a jiná uživatelská rozhraní (např. login formulář). Přidat konfiguraci a testy pro uživatelské interakce (např. co se má stát po kliknutí nebo po zobrazení panelu). Zvýšit bezpečnost UI – zabudovat autorizaci: např. vykreslovat příslušné panely jen pro schválené role. Rozšířit vizualizaci scénářů (pravděpodobně hodit více detailů do *ScenarioVisualizer* nebo přidat grafický diagram toku). Pro lepší používaní doplnit dokumentaci nebo příklady screenshotů, aby bylo zřejmé, jak rozhraní vypadá.

Celkově projekt **NebulaLang** představuje komplexní, modulární rámec pro bezpečnostní aplikace s důrazem na kontext a adaptivní chování. Soubory definují širokou škálu komponent – od skriptovacího DSL, přes orchestrace až po výstupní GUI. Implementace je důsledná a pokrytá testy, ale stále zůstává spíše experimentální. Doporučujeme pokračovat ve zdokonalování architektury (robustnější tokeny, perzistenci logů), rozšířit dokumentaci a ladicí nástroje (další pane­ly či vizualizace), a iterovat nad stabilitou (sandbox, automatizované testy). S takovými kroky by se NebulaLang mohla stát výkonným prostředkem pro inteligentní a bezpečnostně orientované systémy.
