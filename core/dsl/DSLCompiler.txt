// DSLCompiler.js

function tokenize(input) {
  const regex = /\s*(->|\.\.|=>|==|!=|<=|>=|=|!|\+|\-|\*|\/|%|<|>|:|,|\(|\)|"[^"]*"|\d+(?:\.\d+)?|[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*)\s*/g;

  const tokens = [];
  let match;

  while ((match = regex.exec(input)) !== null) {
    const value = match[1];
    let type = 'UNKNOWN';
    const lower = value.toLowerCase();

    if (['if', 'then', 'elseif', 'else', 'end', 'and', 'or', 'not', 'each', 'in', 'break', 'continue', 'pause', 'keep', 'match', 'case', 'stream','shadow','atomic','predict'].includes(lower)) type = 'KEYWORD';
    else if (['==', '!=', '<', '>', '<=', '>=', 'like', '=', '+', '-', '*', '/', '->', '..', '%'].includes(value)) type = 'OPERATOR';
    else if (/^"[^"]*"$/.test(value)) type = 'STRING';
    else if (value === '!') type = 'OPERATOR';
    else if (value === '(') type = 'LPAREN';
    else if (value === ',') type = 'COMMA';
    else if (/^\d+(\.\d+)?$/.test(value)) type = 'NUMBER';
    else if (value === ')') type = 'RPAREN';
    else if (/^\d+(\.\d+)?$/.test(value)) type = 'NUMBER';
    else if (/^[\w\.]+$/.test(value)) type = 'IDENTIFIER';
    else if (value === ':') type = 'COLON';


    tokens.push({ type, value });
  }

  return tokens;
}

function parseTokens(tokens) {
  let i = 0;

  function expectType(type) {
    const token = tokens[i];
    if (!token || token.type !== type) {
      throw new Error(`Expected ${type}, got ${token?.type} (${token?.value})`);
    }
    i++;
    return token;
  }

  function expectKeyword(value) {
    const token = tokens[i];
    if (!token || token.type !== 'KEYWORD' || token.value.toLowerCase() !== value.toLowerCase()) {
      throw new Error(`Expected KEYWORD '${value}', got ${token?.type} (${token?.value})`);
    }
    i++;
    return token;
  }

  function parseExpression() {
    if (tokens[i] && tokens[i].type === 'OPERATOR' && tokens[i].value === '!') {
      const operator = tokens[i++].value;
      const argument = parseExpression(); // rekurzivnƒõ parsuj v√Ωraz za "!"
      const unary = {
        type: 'UnaryExpression',
        operator,
        argument
      };
      console.log('üß™ Parsed unary expression:', JSON.stringify(unary, null, 2));
      return unary;
    }

    // Jinak pokraƒçuj bin√°rn√≠m v√Ωrazem
    let left = parseBinaryExpression();

    // Zpracuj logick√© v√Ωrazy typu a and b
    while (
      tokens[i] &&
      tokens[i].type === 'KEYWORD' &&
      ['and', 'or'].includes(tokens[i].value.toLowerCase())
    ) {
      const operator = tokens[i++].value.toLowerCase();
      const right = parseExpression(); // üëà tady m√≠sto parseSimpleExpression
      if (!right) throw new Error(`‚ùå Expected expression after '${operator}'`);
      left = {
        type: 'LogicalExpression',
        operator,
        left,
        right
      };
    }


    const out = ['NUMBER', 'STRING', 'IDENTIFIER'].includes(left?.type)
      ? normalizeToken(left)
      : left;
    return out;

  }

  function parseLetStatement() {
    consume('KEYWORD', 'keep');
    const nameToken = consume('IDENTIFIER');

    // Voliteln√Ω oper√°tor =
    if (match('OPERATOR', '=')) {
      consume('OPERATOR', '=');
    }

    const valueExpr = normalizeToken(parseSimpleExpression());

    return {
      type: 'VariableDeclaration',
      name: nameToken.value,
      value: valueExpr
    };
  }

  function parseSimpleExpression() {
    
    const tok = tokens[i];
    console.log("üîç SimpleExpression:", tok?.type, tok?.value)
    if (!tok) return null;

    // ( ... )
    if (tok.type === 'LPAREN') {
      i++;
      const expr = parseExpression();
      expectType('RPAREN');
      return expr;
    }

    // number
    if (tok.type === 'NUMBER') {
      i++;
      return { type: 'NumberLiteral', value: parseFloat(tok.value) };
    }

    // string
    if (tok.type === 'STRING') {
      i++;
      return { type: 'StringLiteral', value: tok.value };
    }

    // identifier, member expression, function call
    if (tok.type === 'IDENTIFIER') {
      i++;

      // boolean: true / false
      if (tok.value === 'true' || tok.value === 'false') {
        return { type: 'BooleanLiteral', value: tok.value === 'true' };
      }

      // teƒçkov√° notace: system.admin ‚Üí MemberExpression chain
      if (tok.value.includes('.')) {
        const parts = tok.value.split('.');
        let node = { type: 'Identifier', value: parts[0] };
        for (let j = 1; j < parts.length; j++) {
          node = { type: 'MemberExpression', object: node, property: parts[j] };
        }
        return node;
      }
      
      // vol√°n√≠ funkce se z√°vorkami: f(...)
      if (tokens[i] && tokens[i].type === 'LPAREN') {
        i--;
        return parseFunctionCall();
      }

      // obyƒçejn√Ω identifik√°tor
      return { type: 'Identifier', value: tok.value };
    }

    // jin√Ω neƒçekan√Ω token: vra≈• null
    return null;
  }

  function normalizeToken(token) {
    if (!token || typeof token !== 'object') return token;

    if (token.type === 'NUMBER') {
      return { type: 'NumberLiteral', value: parseFloat(token.value) };
    }
    if (token.type === 'STRING') {
      return { type: 'StringLiteral', value: token.value };
    }
    if (token.type === 'IDENTIFIER') {
      return { type: 'Identifier', value: token.value };
    }
    return token;
  }

  function parseBinaryExpression() {
    let left = parseSimpleExpression(); // ‚úÖ
    if (!left) return null;


    if (!left) {
      throw new Error(`‚ùå Expected expression before operator '${tokens[i]?.value}'`);
    }


    while (
      tokens[i] &&
      tokens[i].type === 'OPERATOR' &&
      ['+', '-', '*', '/', '%', '==', '!=', '<', '>', '<=', '>=', 'like'].includes(tokens[i].value)
    ) {
      const operator = tokens[i++].value;
      const right = parseSimpleExpression(); // ‚Üê pou≈æij stejn√Ω parser bez fallbacku
      left = { type: 'BinaryExpression', operator, left, right };
    }

    console.log('üß™ BinaryExpression:', JSON.stringify(left, null, 2));

    return left;
  }

  function parseFunctionCall() {
    const func = expectType('IDENTIFIER');
    expectType('LPAREN');
    const args = [];

    while (tokens[i] && tokens[i].type !== 'RPAREN') {
      const token = tokens[i++];

      if (['STRING', 'IDENTIFIER', 'NUMBER'].includes(token.type)) {
        args.push(normalizeToken(token));
      } else {
        throw new Error(`‚ùå Neoƒçek√°van√Ω typ argumentu: ${token.type}`);
      }

      if (tokens[i]?.type === 'COMMA') i++; // p≈ôeskoƒç ƒç√°rku
    }

    expectType('RPAREN');
    return {
      type: 'FunctionCall',
      name: func.value,
      arguments: args
    };
  }

  function parseBlock(endKeywords = ['else', 'end']) {
    
    const expressions = [];

    while (i < tokens.length) {
      const token = tokens[i];
      console.log(`parseBlock: token ${token.type} (${token.value})`);

      if (token.type === 'OPERATOR' && token.value === '->') {
        throw new Error("Unexpected '->' in block. Case body must be parsed using parseCaseBodyOrArrow.");
      }

      if (token.type === 'OPERATOR') {
        console.warn(`‚ö†Ô∏è Ignoring standalone operator '${token.value}' in block`);
        i++;
        continue;
      }

      if (token.type === 'KEYWORD' && endKeywords.includes(token.value.toLowerCase())) {
        break;
      }

      if (token.type === 'KEYWORD' && token.value === 'return') {
        const value = parseSimpleExpression();
        throw { type: 'ReturnSignal', value };
      }

      if (token.type === 'KEYWORD' && token.value === 'continue') {
        throw { type: 'ContinueSignal' };
      }

      if (token.type === 'STRING') {
        expressions.push({
          type: 'StringLiteral',
          value: token.value
        });
        i++;
        continue;
      }

      if (token.type === 'IDENTIFIER' && token.value === 'log') {
        const stmt = parseStatement();
        if (stmt) expressions.push(stmt);
        continue;
      }
      
      if (token.type === 'KEYWORD') {
        const keyword = token.value.toLowerCase();

        if (keyword === 'break') {
          i++;
          expressions.push({ type: 'BreakStatement' });
          continue;
        }

        if (keyword === 'stream') {
          const stmt = parseStatement(); // parseStatement u≈æ 'stream' um√≠
          if (stmt) expressions.push(stmt);
          continue;
        }



        if (keyword === 'continue') {
          i++;
          expressions.push({ type: 'ContinueStatement' });
          continue;
        }

        if (keyword === 'pause') {
          i++;
          expressions.push({ type: 'PauseStatement' });
          continue;
        }

        if (keyword === 'if') {
          const stmt = parseStatement(); // nebo parseIfStatement()
          if (stmt) {
            expressions.push(stmt);
          } else {
            console.warn('‚ö†Ô∏è parseStatement() vr√°til null, v√Ωraz nebude p≈ôid√°n.');
          }
          continue;
        }
        
        if (keyword === 'each') {
          try {
            const stmt = parseEachStatement();
            if (stmt) {
              expressions.push(stmt);
            } else {
              console.warn('‚ö†Ô∏è parseEachStatement() vr√°til null nebo undefined.');
            }
          } catch (err) {
            console.error(`‚ùå Chyba p≈ôi parsov√°n√≠ 'each': ${err.message}`);
          }
          continue;
        }

        if (keyword === 'keep') {
          const stmt = parseLetStatement();
          expressions.push(stmt);
          continue;
        }

        throw new Error(`Unexpected keyword in block: ${token.value}`);
      }else if (token.type === 'IDENTIFIER') {
        if (token.value === 'log') {
          const stmt = parseStatement();
          expressions.push(stmt);
          continue;
        }

        const stmt = parseStatement();
        if (stmt) {
          expressions.push(stmt);
        } else {
          console.warn(`‚ö†Ô∏è parseStatement() vr√°til null pro IDENTIFIER: ${token.value}`);
        }
        continue;
      }else if (token.type === 'NUMBER') {
        expressions.push(normalizeToken(token)); // ‚úÖ
        i++;
        continue;
      }else if (token.type === 'BOOLEAN') {
        expressions.push({
          type: 'BooleanLiteral',
          value: token.value === 'true'
        });
        i++;
        continue;
      } else {
        throw new Error(`Unexpected token type in block: ${token.type}`);
      }
    }

    const filtered = expressions.filter(e => e !== null && e !== undefined);
    return filtered;

  }

  function parseEachLoop(tokens, current) {
    // Oƒçek√°v√°me: each IDENTIFIER in IDENTIFIER
    const eachToken = tokens[current];
    const iteratorToken = tokens[current + 1];
    const inToken = tokens[current + 2];
    const iterableToken = tokens[current + 3];

    if (
      eachToken.type !== 'KEYWORD' || eachToken.value !== 'each' ||
      iteratorToken.type !== 'IDENTIFIER' ||
      inToken.type !== 'KEYWORD' || inToken.value !== 'in' ||
      iterableToken.type !== 'IDENTIFIER'
    ) {
      throw new Error(`‚ùå Neplatn√° syntaxe each cyklu`);
    }

    current += 4;

    const body = [];
    while (tokens[current] && !(tokens[current].type === 'KEYWORD' && tokens[current].value === 'end')) {
      body.push(parseStatement(tokens, current));
      current = advanceToNext(tokens, current);
    }

    return {
      type: 'EachLoop',
      iterator: iteratorToken.value,
      iterable: iterableToken.value,
      body
    };
  }

  function parseEachStatement() {
    consume('KEYWORD', 'each');
    const iterator = consume('IDENTIFIER').value;
    consume('KEYWORD', 'in');
    const iterable = consume('IDENTIFIER').value;

    const body = [];
    while (!match('KEYWORD', 'end')) {
      body.push(parseStatement());
    }
    consume('KEYWORD', 'end');

    return {
      type: 'EachStatement',
      iterator,
      iterable,
      body
    };
  }

  function parseLogMatchStatement() {
    // log match <expr> (case ...)+ [else ...] end
    let matchValue = null;
    if (!match('KEYWORD', 'case') && !match('KEYWORD', 'else') && !match('KEYWORD', 'end')) {
      matchValue = parseExpression();
    }


    const cases = [];
    let defaultCase = null;

    while (true) {
      const t = peek();
      if (!t) throw new Error("‚ùå Unexpected end, expected 'case' or 'else' in match");
      if (t.type === 'KEYWORD' && t.value.toLowerCase() === 'case') {
        consume('KEYWORD', 'case');
        cases.push(parseCaseClause());
        continue;
      }
      if (t.type === 'KEYWORD' && t.value.toLowerCase() === 'else') {
        consume('KEYWORD', 'else');
        defaultCase = parseCaseBodyOrArrow();
        break;
      }
      if (t.type === 'KEYWORD' && t.value.toLowerCase() === 'end') {
        break;
      }
      throw new Error(`‚ùå Unexpected token in match: ${t.type} (${t.value})`);
    }

    expectKeyword('end');

    return {
      type: 'LogMatchStatement',
      value: matchValue,
      cases,
      default: defaultCase
    };
  }

  function parseCaseClause() {
    const isGuardOnly =
      peek()?.type === 'IDENTIFIER' &&
      peek(1)?.type === 'OPERATOR' &&
      ['==', '!=', '<', '>', '<=', '>=', 'like'].includes(peek(1).value);

    let pattern = null;
    let guard = null;

    if (isGuardOnly) {
      guard = parseExpression();
    } else {
      pattern = parsePattern();

      if (match('KEYWORD', 'if')) {
        consume('KEYWORD', 'if');
        guard = parseExpression();
        if (!isValidCondition(guard)) {
          throw new Error('‚ùå Neplatn√Ω v√Ωraz ve case guardu.');
        }
      }
    }

    if (!match('OPERATOR', '->')) {
      throw new Error("‚ùå Missing '->' after case clause");
    }

    consume('OPERATOR', '->');
    const expressionBody = parseExpression();

    return {
      type: 'LogMatchCase',
      pattern,
      guard,
      expressionBody
    };
  }

  function parseCaseBodyOrArrow() {
    // podpora: case X -> <expr>
    if (match('OPERATOR', '->')) {
      consume('OPERATOR', '->');
      const expressionBody = parseExpression();
      return { expressionBody };
    }
    // jinak ƒçteme blok a≈æ do case/else/end
    const body = parseBlock(['case', 'else', 'end']);
    return { body };
  }

  function parsePattern() {
    const t = peek();
    if (!t) throw new Error('‚ùå Expected pattern');

    // wildcard _
    if (t.type === 'IDENTIFIER' && t.value === '_') {
      i++;
      return { type: 'WildcardPattern' };
    }

    if (t.type === 'IDENTIFIER' && /^\d+\.\.\d+$/.test(t.value)) {
      throw new Error(`‚ùå Suspicious compound identifier '${t.value}', probably missed range tokenization`);
    }

    // range: <expr> .. <expr>
    const startExpr = parseExpression();
    if (!startExpr) throw new Error('‚ùå Expected pattern expression');

    if (match('OPERATOR', '..')) {
      consume('OPERATOR', '..');
      const endExpr = parseExpression();
      if (!endExpr) throw new Error('‚ùå Expected range end expression');
      return {
        type: 'RangePattern',
        start: normalizeToken(startExpr),
        end: normalizeToken(endExpr)
      };
    }

    // literal/identifier pattern
    const node = normalizeToken(startExpr);
    if (!node) throw new Error('‚ùå Invalid pattern');
    return { type: 'ValuePattern', value: node };
  }

  function consume(expectedType, expectedValue = null) {
    const token = tokens[i];
    if (!token) {
      throw new Error(`Unexpected end of input, expected ${expectedType}${expectedValue ? ` '${expectedValue}'` : ''}`);
    }

    if (token.type !== expectedType) {
      throw new Error(`Expected ${expectedType}, got ${token.type} (${token.value})`);
    }

    if (expectedValue && token.value.toLowerCase() !== expectedValue.toLowerCase()) {
      throw new Error(`Expected ${expectedType} '${expectedValue}', got ${token.type} (${token.value})`);
    }

    i++;
    return token;
  }

  function match(type, value = null) {
    const token = tokens[i];
    return token &&
      token.type === type &&
      (value === null || token.value.toLowerCase() === value.toLowerCase());
  }

  function peek(offset = 0) {
    return tokens[i + offset];
  }

  function isValidCondition(node) {
    if (!node || typeof node !== 'object') return false;

    switch (node.type) {
      case 'Identifier':
      case 'StringLiteral':
      case 'NumberLiteral':
      case 'BooleanLiteral':
      case 'MemberExpression':
        return true;

      case 'UnaryExpression':
        return isValidCondition(node.argument);

      case 'BinaryExpression':
      case 'LogicalExpression':
        return isValidCondition(node.left) && isValidCondition(node.right);

      default:
        return false;
    }
  }


  function parseStatement() {
    const token = peek();

    if (token.type === 'KEYWORD' && token.value === 'if') {
      i++;
      const condition = parseExpression();
      if (!isValidCondition(condition)) {
        throw new Error('‚ùå Nevalidn√≠ podm√≠nka v if statementu.');
      }

      expectKeyword('then');
      const consequence = parseBlock(['elseif', 'else', 'end']);

      const elseifBlocks = [];
      while (match('KEYWORD', 'elseif')) {
        consume('KEYWORD', 'elseif');
        const elseifCondition = parseExpression();
        expectKeyword('then');
        const elseifConsequence = parseBlock(['elseif', 'else', 'end']);
        elseifBlocks.push({ condition: elseifCondition, consequence: elseifConsequence });
      }

      let alternative = null;
      if (match('KEYWORD', 'else')) {
        consume('KEYWORD', 'else');
        alternative = parseBlock(['end']);
      }

      expectKeyword('end');

      return {
        type: 'IfStatement',
        condition,
        consequence,
        elseifBlocks,
        alternative
      };
    }

    if (token.type === 'KEYWORD' && token.value === 'keep') {
      return parseLetStatement();
    }

    if (token.type === 'KEYWORD' && token.value === 'each') {
      return parseEachStatement();
    }

    if (token.type === 'KEYWORD' && token.value === 'stream') {
      consume('KEYWORD', 'stream');

      // teƒè si vezmeme voliteln√Ω label (n√°zev streamu)
      let label = null;
      if (match('IDENTIFIER')) {
        label = consume('IDENTIFIER').value;
      }

      // voliteln√Ω kvalifik√°tor
      let qualifier = null;
      if (match('KEYWORD') || match('IDENTIFIER')) {
        const q = peek();
        if (['shadow', 'atomic', 'predict'].includes(q.value)) {
          qualifier = consume(q.type).value;
        }
      }

      const body = parseBlock(['end']);
      expectKeyword('end');

      return {
        type: 'StreamBlock',
        label,       // ‚Üê p≈ôidej label do AST
        qualifier,
        body
      };

    }
    
    if (token.type === 'IDENTIFIER' && token.value === 'log') {
      console.log('üß≠ Detekov√°n log statement')
      i++
      if (match('KEYWORD', 'match') || (peek()?.type === 'IDENTIFIER' && peek().value === 'match')) {
        // consume 'match' jako KEYWORD nebo IDENTIFIER (pro star≈°√≠ tokenizaci)
        if (match('KEYWORD', 'match')) consume('KEYWORD', 'match');
        else consume('IDENTIFIER'); // 'match'
        return parseLogMatchStatement();
      }
      const expr = parseExpression();
      if (!expr) {
        throw new Error(`‚ùå Expected expression after log`);
      }
      console.log('üì§ Log argument typ:', expr.type)
      console.log('üì§ Parsed log argument:', JSON.stringify(expr, null, 2));
      console.log('üîç LogStatement AST:', JSON.stringify(expr, null, 2));
      return {
        type: 'LogStatement',
        argument: expr
      };
    }

    if (token.type === 'IDENTIFIER') {
      // speci√°l pro 'log' u≈æ ≈ôe≈°√≠≈° v√Ω≈°e ‚Äì sem se nedostane

      // lookahead: pokud hned za identifik√°torem n√°sleduje oper√°tor, je to v√Ωraz (ne vol√°n√≠)
      const next = peek(1);
      const opSet = ['+', '-', '*', '/', '%', '==', '!=', '<', '>', '<=', '>=', 'like', '='];
      if (next && next.type === 'OPERATOR' && opSet.includes(next.value)) {
        const expr = parseExpression();
        return { type: 'ExpressionStatement', expression: expr };
      }

      // jinak je to bez-z√°vorkov√© vol√°n√≠ funkce s argumenty jako v√Ωrazy
      const funcName = consume('IDENTIFIER').value;
      const args = [];
      while (tokens[i] && ['STRING', 'IDENTIFIER', 'NUMBER', 'LPAREN'].includes(tokens[i].type)) {
        const arg = parseExpression();
        if (arg) {
          args.push(normalizeToken(arg));
          console.log('üì• Parsed argument in statement:', JSON.stringify(arg, null, 2));
        } else {
          break;
        }
      }
      if (args.length === 0) {
        console.warn(`‚ö†Ô∏è Funkce '${funcName}' nem√° ≈æ√°dn√© argumenty.`);
      }
      return {
        type: 'FunctionCall',
        name: funcName,
        arguments: args
      };
    }

    if (token.type === 'KEYWORD' && token.value === 'break') {
      consume('KEYWORD', 'break');
      return { type: 'BreakStatement' };
    }

    if (['NUMBER', 'STRING', 'IDENTIFIER'].includes(token.type)) {
      const expr = parseExpression();
      return { type: 'ExpressionStatement', expression: expr };
    }

    console.warn(`‚ö†Ô∏è Neƒçekan√Ω token ve statementu: ${token.type} (${token.value})`);
    return null;

  }

  const statements = [];
  while (i < tokens.length) {
    const token = tokens[i];

    if (token.type === 'KEYWORD' && token.value === 'each') {
      statements.push(parseEachStatement());
    } else if (token.type === 'KEYWORD' && token.value === 'if') {
      statements.push(parseStatement());
    }else if (token.type === 'KEYWORD' && token.value === 'keep') {
      statements.push(parseLetStatement());
    } else if (token.type === 'KEYWORD' && token.value === 'stream') {
      const stmt = parseStatement(); // ta u≈æ si vezme label/qualifier/body
      statements.push(stmt);
    } else {
      const stmt = parseStatement();
      if (stmt) {
        statements.push(stmt);
      } else {
        throw new Error(`Unexpected start of statement: ${token.type} (${token.value})`);
      }

    }
  }

  return statements.length === 1 ? statements[0] : { type: 'Program', body: statements };

}

function validateAST(ast) {
  // pokud p≈ôijde n√°hodou pole, obal ho na Program
  if (Array.isArray(ast)) {
    ast = { type: 'Program', body: ast };
  }

  function walk(node) {
    if (!node) return;
    if (Array.isArray(node)) {
      node.forEach(walk);
      return;
    }
    if (typeof node !== 'object') return;

    // zak√°zan√© "token" typy
    if (node.type === 'IDENTIFIER' || node.type === 'NUMBER') {
      throw new Error(`‚ùå Invalid node type in AST: ${node.type}`);
    }

    // atomick√© uzly, kter√© u≈æ d√°l nelezou
    if (node.type === 'Identifier' ||
        node.type === 'NumberLiteral' ||
        node.type === 'StringLiteral' ||
        node.type === 'BooleanLiteral') {
      return;
    }

    // un√°rn√≠/binar/logick√© v√Ωrazy
    if (node.type === 'UnaryExpression' ||
        node.type === 'BinaryExpression' ||
        node.type === 'LogicalExpression' ||
        node.type === 'MemberExpression') {
      for (const k in node) {
        if (k === 'type') continue;
        walk(node[k]);
      }
      return;
    }

    // bƒõ≈æn√© uzly
    if (node.type === 'LogStatement') {
      walk(node.argument);
      return;
    }
    if (node.type === 'ExpressionStatement') {
      walk(node.expression);
      return;
    }

    // rekurze p≈ôes objekty/pole
    for (const key in node) {
      if (Array.isArray(node[key])) node[key].forEach(walk);
      else if (typeof node[key] === 'object') walk(node[key]);
    }
  }

  walk(ast);

  const allowedRoots = ['IfStatement', 'EachStatement', 'Program'];
  if (!ast || !allowedRoots.includes(ast.type)) {
    throw new Error('Root must be IfStatement, EachStatement or Program');
  }
}

module.exports = {
  tokenize,
  parseTokens,
  validateAST
};