// DSLRuntime.js
const commandHandlers = {}
function evaluate(ast, context) {
  if (!ast || typeof ast.type !== 'string') {
    throw new Error(`‚ùå Invalid AST node: ${JSON.stringify(ast)}`);
  }

  switch (ast.type) {
    case 'UnaryExpression':
    case 'LogicalExpression':
    //case 'BinaryExpression':
    case 'MemberExpression':
    case 'StringLiteral':
    case 'NumberLiteral':
    case 'BooleanLiteral':
      return resolveValue(ast, context);

    case 'LogMatchStatement':
      return evaluateLogMatch(ast, context);


    case 'IfStatement':
      return evaluateIf(ast, context);

    case 'EachStatement':
      return evaluateEach(ast, context);

    case 'VariableDeclaration':
      context[ast.name] = resolveValue(ast.value, context);
      break;

    case 'Program':
      for (const stmt of ast.body) {
        evaluate(stmt, context);
      }
      break;

    case "Identifier":
      return resolveValue(ast, context);

    case 'LogStatement':
      if (!ast.argument) {
        throw new Error(`‚ùå LogStatement missing argument: ${JSON.stringify(ast)}`);
      }
      if (!context || typeof context !== 'object') {
        console.error('‚ö†Ô∏è LogStatement received invalid context:', context);
      }
      //console.log('üì§ Log argument typ:', ast.argument?.type);
      //console.log('üîç LogStatement AST:', JSON.stringify(ast.argument, null, 2));
      const value = resolveValue(ast.argument, context);
      console.log('üìù', value);
      return;
    
    // case 'UnaryExpression':
    //   const arg = evaluate(ast.argument, context);
    //   switch (ast.operator) {
    //     case '!':
    //       return !arg;
    //     default:
    //       throw new Error(`‚ùå Nepodporovan√Ω un√°rn√≠ oper√°tor: ${ast.operator}`);
    //   }
    
    // case 'MemberExpression': {
    //   let obj = evaluate(ast.object, context);
    //   const prop = ast.property;

    //   while (obj && typeof obj === 'object' && obj.hasOwnProperty(prop)) {
    //     obj = obj[prop];
    //     if (typeof obj !== 'object') break;
    //   }

    //   return obj;
    // }

    // case 'LogicalExpression': {
    //   const left = evaluate(ast.left, context);
    //   const right = evaluate(ast.right, context);

    //   switch (ast.operator) {
    //     case 'and':
    //       return left && right;
    //     case 'or':
    //       return left || right;
    //     default:
    //       throw new Error(`‚ùå Nepodporovan√Ω logick√Ω oper√°tor: ${ast.operator}`);
    //   }
    // }

    // case 'StringLiteral': {
    //   return ast.value.replace(/^"|"$/g, '');
    // }

    // case 'NumberLiteral':
    //   return ast.value;

    case 'BinaryExpression': {
      const left = evaluate(ast.left, context);
      const right = evaluate(ast.right, context);

      switch (ast.operator) {
        case '+': return left + right;
        case 'like': {
          if (typeof left === 'string' && typeof right === 'string') {
          // Escape speci√°ln√≠ regex znaky (kromƒõ hvƒõzdiƒçky)
          const escaped = right.replace(/[-[\]/{}()+?.\\^$|]/g, '\\$&');
          // Nahradit hvƒõzdiƒçky za .* pro "libovoln√Ω znak libovolnƒõkr√°t"
          const wildcardPattern = escaped.replace(/\*/g, '.*');
          try {
            const regex = new RegExp(`^${wildcardPattern}$`, 'i'); // full match
            return regex.test(left);
          } catch (err) {
            console.warn(`‚ùå Chybn√Ω regex v 'like': ${wildcardPattern}`, err);
            return false;
          }
        }
        return false;

        }
        case '-': return left - right;
        case '*': return left * right;
        case '/': return left / right;
        case '%': return left % right; // ‚Üê DOPL≈á TUTO ≈ò√ÅDKU
        case '==': return left === right;
        case '!=': return left !== right;
        case '<': return left < right;
        case '>': return left > right;
        case '<=': return left <= right;
        case '>=': return left >= right;
        default:
          throw new Error(`‚ùå Nepodporovan√Ω oper√°tor: ${ast.operator}`);
      }

    }

    case 'FunctionCall':
      return executeFunction(ast, context);

    case 'BreakStatement':
      throw { type: 'BreakSignal' };
    
    case 'like': {
      if (typeof left === 'string' && typeof right === 'string') {
        // M≈Ø≈æe≈° j√≠t na regul√°rn√≠ v√Ωrazy nebo jen .includes:
        return left.includes(right); // jednoduch√©
        // return new RegExp(right, 'i').test(left); // pokroƒçil√©
      }
      return false;
    }


    // case 'BooleanLiteral':
    //   return ast.value;

    // case '==':
    //   return left === right;

    default:
      throw new Error(`‚õîÔ∏è Unsupported AST type: ${ast.type}`);
  }
}

function evaluateLogMatch(node, context) {
  const value = evaluate(node.value, context);

  if (node.value?.type === 'Identifier' && !(node.value.value in context)) {
    console.warn(`‚ö†Ô∏è Promƒõnn√° '${node.value.value}' nebyla nalezena.`);
  }

  for (const c of node.cases || []) {
    if (patternMatches(c.pattern, value, context)) {
      // Kontext obohat√≠me o 'it' a zachov√°me existuj√≠c√≠ promƒõnn√© (vƒçetnƒõ 'score')
      const enrichedContext = {
        ...context,
        variables: {
          ...(context.variables || {}),
          ...context,
          it: value
        }
      };

      // Guard bezpeƒçnƒõ vyhodnot√≠me
      let passed = true;
      if (c.guard) {
        try {
          passed = truthy(evaluate(c.guard, enrichedContext));
        } catch (e) {
          console.error("Guard evaluation failed:", c.guard, e);
          passed = false;
        }
      }

      if (passed) {
        if (c.expressionBody) {
          console.log('üß™ Guard context variables:', Object.keys(enrichedContext.variables));
          const out = evaluate(c.expressionBody, enrichedContext);
          if (out == null) {
            console.warn("Expression body returned null:", c.expressionBody);
          }
          logValue(out);
          return out;
        }
        return evaluateBlock(c.body, enrichedContext);
      }
    }
  }

  // default vƒõtev
  if (node.default) {
    const enrichedContext = {
      ...context,
      variables: {
        ...(context.variables || {}),
        ...context,
        it: value
      }
    };

    if (node.default.expressionBody) {
      const out = evaluate(node.default.expressionBody, enrichedContext);
      logValue(out);
      return out;
    }
    return evaluateBlock(node.default.body, enrichedContext);
  }

  return null;
}

function patternMatches(pattern, value, context) {
  if (!pattern) {
    // Pokud nen√≠ pattern, p≈ôedpokl√°d√°me, ≈æe se vyhodnocuje pouze guard
    return true;
  }

  switch (pattern.type) {
    case 'WildcardPattern':
      return true;
    case 'ValuePattern': {
      const v = materialize(pattern.value, withIt(context, value));
      return deepEquals(v, value);
    }
    case 'RangePattern': {
      const start = materialize(pattern.start, context);
      const end = materialize(pattern.end, context);
      if (typeof start === 'number' && typeof end === 'number' && typeof value === 'number') {
        return value >= start && value <= end;
      }
      if (typeof start === 'string' && typeof end === 'string' && typeof value === 'string') {
        return value >= start && value <= end;
      }
      return false;
    }
    default:
      throw new Error(`Unknown pattern type: ${pattern.type}`);
  }
}

// Pomocn√© utilitky ‚Äì uprav podle sv√©ho runtime
function withIt(ctx, itVal) {
  return { ...ctx, it: itVal };
}

function materialize(node, ctx) {
  // evaluate() pokud node je AST; pokud u≈æ je literal, vra≈• p≈ô√≠mo
  if (node && typeof node === 'object' && node.type) return evaluate(node, ctx);
  return node;
}

function evaluateBlock(body, ctx) {
  let last = null;
  for (const stmt of body || []) {
    last = evaluate(stmt, ctx);
  }
  return last;
}

function truthy(x) { return !!x; }

function deepEquals(a, b) {
  if (a === b) return true;
  if (a && b && typeof a === 'object' && typeof b === 'object') {
    if (Array.isArray(a) !== Array.isArray(b)) return false;
    if (Array.isArray(a)) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) if (!deepEquals(a[i], b[i])) return false;
      return true;
    }
    const ak = Object.keys(a), bk = Object.keys(b);
    if (ak.length !== bk.length) return false;
    for (const k of ak) if (!deepEquals(a[k], b[k])) return false;
    return true;
  }
  return false;
}

function logValue(v) {
  // napoj na tv≈Øj existuj√≠c√≠ log sink
  console.log(v);
}

function evaluateIf(ast, context) {
  if (!ast.condition) {
    throw new Error(`‚ùå Invalid IfStatement condition: ${JSON.stringify(ast.condition)}`);
  }

  const resolve = (node) => resolveValue(node, context);
  let result;

  const condition = ast.condition;

  if (condition.type === 'BinaryExpression') {
    result = compare(resolve(condition.left), condition.operator, resolve(condition.right));
  } else if (condition.type === 'LogicalExpression') {
    const leftResult = evaluateIf({ condition: condition.left }, context);
    const rightResult = evaluateIf({ condition: condition.right }, context);

    if (condition.operator === 'and') {
      result = leftResult && rightResult;
    } else if (condition.operator === 'or') {
      result = leftResult || rightResult;
    }
  } else if (condition.type === 'MemberExpression') {
    const obj = evaluate(condition.object, context);
    result = !!obj?.[condition.property];
  } else if (condition.type === 'UnaryExpression' && condition.operator === '!') {
    const value = evaluate(condition.argument, context);
    result = !value;
  } else {
    throw new Error(`Unsupported condition type: ${condition.type}`);
  }

  let block = result ? ast.consequence : null;

  if (!result && ast.elseifBlocks?.length) {
    for (const elseif of ast.elseifBlocks) {
      const elseifCondition = elseif.condition;
      let elseifResult;

      if (elseifCondition.type === 'BinaryExpression') {
        elseifResult = compare(resolve(elseifCondition.left), elseifCondition.operator, resolve(elseifCondition.right));
      } else {
        elseifResult = evaluateIf({ condition: elseifCondition }, context);
      }

      if (elseifResult) {
        block = elseif.consequence;
        break;
      }
    }
  }

  if (!block && ast.alternative) {
    block = ast.alternative;
  }

  const expressions = Array.isArray(block) ? block : block ? [block] : [];

  const scopedContext = Object.create(context);
  expressions.forEach(expr => evaluate(expr, scopedContext));

  return result;
}

function evaluateEach(ast, context) {
  const collection = resolveIdentifier(ast.iterable, context); // nebo resolveValue(ast.source, context)
  const iterator = ast.iterator;
  const body = ast.body;

  if (!Array.isArray(collection)) {
    throw new Error(`‚ùå EachStatement source is not iterable: ${JSON.stringify(collection)}`);
  }

  try {
    for (const item of collection) {
      //const localContext = { ...context, [iterator]: item };
      const localContext = Object.create(context);
      localContext[iterator] = item;

      for (const expr of body) {
        try {
          evaluate(expr, localContext);
        } catch (e) {
          if (e.type === 'ContinueSignal') break;
          else throw e;
        }
      }
    }
  } catch (e) {
    if (e.type === 'BreakSignal') {
      console.log('üõë Smyƒçka ukonƒçena p≈ô√≠kazem break');
    } else {
      throw e;
    }
  }
}

function executeBlock(expressions, context) {
  for (const expr of expressions) {
    if (expr.type === 'FunctionCall') {
      executeFunction(expr, context);
    } else if (expr.type === 'NumberLiteral') {
      // m≈Ø≈æe≈° vracet hodnotu nebo ignorovat
    } else if (expr.type === 'BreakStatement') {
      return 'break';
    } else if (expr.type === 'ContinueStatement') {
      return 'continue';
    } else if (expr.type === 'PauseStatement') {
      return 'pause';
    } else if (expr.type === 'IfStatement') {
      evaluate(expr, context); // rekurzivn√≠ vyhodnocen√≠
    } else {
      console.warn('‚õîÔ∏è Nepodporovan√Ω v√Ωraz:', expr);
    }
  }
}

function resolveValue(node, context) {
  if (!node || typeof node.type !== 'string') {
    throw new Error(`‚ùå Invalid node passed to resolveValue: ${JSON.stringify(node)}`);
  }

  switch (node.type) {
    case 'LogicalExpression': {
      const left = resolveValue(node.left, context);
      const right = resolveValue(node.right, context);
      if (node.operator === 'and') return left && right;
      if (node.operator === 'or') return left || right;
      throw new Error(`Unsupported logical operator: ${node.operator}`);
    }

    case 'StringLiteral':
      return node.value.replace(/^"|"$/g, '');

    case 'BooleanLiteral':
      return node.value;

    case 'MemberExpression': {
      const obj = resolveValue(node.object, context);
      if (typeof obj !== 'object' || obj === null) {
        throw new Error(`‚ùå Cannot access property '${node.property}' on non-object`);
      }
      if (!(node.property in obj)) {
        throw new Error(`‚ùå Property '${node.property}' not found in object`);
      }
      return obj[node.property];
    }

    case 'BinaryExpression': {
      const left = resolveValue(node.left, context);
      const right = resolveValue(node.right, context);
      switch (node.operator) {
        case '+': return left + right;
        case 'like': {
          if (typeof left === 'string' && typeof right === 'string') {
            const escaped = right.replace(/[-[\]/{}()+?.\\^$|]/g, '\\$&'); // escape speci√°ln√≠ znaky
            const pattern = escaped.replace(/\*/g, '.*');                  // nahradit * za .* pro "wildcard"
            const regex = new RegExp(`^${pattern}$`, 'i');                 // ^...$ = full match
            return regex.test(left);
          }
          return false;
        }
        case '/': return left / right;
        case '*': return left * right;
        case '-': return left - right;
        case '==': return left == right;
        case '!=': return left != right;
        case '>': return left > right;
        case '<': return left < right;
        case '>=': return left >= right;
        case '<=': return left <= right;
        default:
          throw new Error(`Unsupported binary operator: ${node.operator}`);
      }
    }

    case 'Identifier':
    case 'IDENTIFIER': {
      const varName = node.value;

      // üëÄ Podpora pro context.it
      if (context?.variables && varName in context.variables) {
        return context.variables[varName];
      }

      if ('it' in context && varName === 'it') {
        return context.it;
      }

      if (varName in context) {
        return context[varName];
      }

      throw new Error(`‚ùå Variable '${varName}' not found in context`);
    }

    case 'NumberLiteral':
      return Number(node.value);

    default:
      throw new Error(`Unsupported node type in condition: ${node.type}`);

  }
}


function resolveIdentifier(path, context) {
  const parts = path.split(".");
  let value = context;
  for (const part of parts) {
    if (value && part in value) {
      value = value[part];
    } else {
      return undefined; // nebo throw error
    }
  }
  return value;
}

function stripQuotes(str) {
  return str.replace(/^"|"$/g, '');
}

function compare(left, operator, right) {
  const l = normalize(left);
  const r = normalize(right);

  switch (operator) {
    case '==': return l === r;
    case '!=': return l !== r;
    case '>': return l > r;
    case '<': return l < r;
    case '>=': return l >= r;
    case '<=': return l <= r;
    case 'like':
      if (typeof l !== 'string' || typeof r !== 'string') return false;
      const safe = r.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&'); // escape v≈°e
      const wildcard = safe.replace(/\\\*/g, '.*'); // nahraƒè * jen kdy≈æ je v DSL pou≈æito
      const regex = new RegExp(`^${wildcard}$`, 'i');
      return regex.test(l);
    // case 'and': return l <= r;
    default: throw new Error(`Unsupported operator: ${operator}`);
  }
}

function normalize(value) {
  if (typeof value === 'boolean') return value;
  if (typeof value === 'number') return value !== 0;
  if (typeof value === 'string') {
    const v = value.toLowerCase().trim();
    if (v === 'true' || v === '1') return true;
    if (v === 'false' || v === '0') return false;
    return value;
  }
  return value;
}


const registryCommands = () => {
  const defaultCommands = {
    trigger: (msg, context) => console.log(`üö® Triggering action: ${msg}`),
    log: (msg, context) => {
      const output = typeof msg === 'object' ? JSON.stringify(msg, null, 2) : msg;
      console.log(`üìù Log: ${output}`);
    },
    send: (msg, context) => console.log(`üì§ Sending message: ${msg}`),
    notify: (msg, context) => console.log(`üîî Notification: ${msg}`)
  }

  Object.entries(defaultCommands).forEach(([name, handler]) => {
    registerCommand(name, handler);
  });

  // add new functions
};

async function executeEachLoop(node, context) {
  const iterable = resolveIdentifier(node.iterable, context);
  if (!Array.isArray(iterable)) {
    console.warn(`‚ö†Ô∏è '${node.iterable}' nen√≠ pole`);
    return;
  }

  for (const item of iterable) {
    context[node.iterator] = item;

    const result = executeBlock(node.body, context);
    if (result === 'break') break;
    if (result === 'continue') continue;
    if (result === 'pause') await sleep(1000); // nebo jin√° logika
  }
}

function registerCommand(name, handler) {
  commandHandlers[name] = handler;
}

function executeFunction(funcCall, context) {
  if (!funcCall || typeof funcCall !== 'object') {
    console.warn('‚ö†Ô∏è Neplatn√© vol√°n√≠ funkce:', funcCall);
    return;
  }

  const name = funcCall.name;
  const args = funcCall.arguments.map(arg => resolveValue(arg, context));

  registryCommands()

  const fn = commandHandlers[name];
  if (!fn) {
    console.log(`‚öôÔ∏è Unknown function: ${name}`);
    return;
  }

  fn(...args, context);

}

module.exports = {
  evaluate
};